# This is an adapted version of the ILI934X driver as below.
# It works with multiple fonts and also works with the esp32 H/W SPI implementation
# Also includes a word wrap print function
# Proportional fonts are generated by Peter Hinch's Font-to-py
# MIT License; Copyright (c) 2017 Jeffrey N. Magee

# This file is part of MicroPython ILI934X driver
# Copyright (c) 2016 - 2017 Radomir Dopieralski, Mika Tuupola
#
# Licensed under the MIT license:
#   http://www.opensource.org/licenses/mit-license.php
#
# Project home:
#   https://github.com/tuupola/micropython-ili934x

import ustruct
from time import sleep_ms
from micropython import const

_RDDSDR = const(0x0F)  # Read Display Self-Diagnostic Result
_SLPOUT = const(0x11)  # Sleep Out
_INVON = const(0x21)  # Display Inversion On
_GAMSET = const(0x26)  # Gamma Set
_DISPOFF = const(0x28)  # Display Off
_DISPON = const(0x29)  # Display On
_CASET = const(0x2A)  # Column Address Set
_PASET = const(0x2B)  # Page Address Set
_RAMWR = const(0x2C)  # Memory Write
_RAMRD = const(0x2E)  # Memory Read
_MADCTL = const(0x36)  # Memory Access Control
_VSCRSADD = const(0x37)  # Vertical Scrolling Start Address
_PIXSET = const(0x3A)  # Pixel Format Set
_PWCTRLA = const(0xCB)  # Power Control A
_PWCRTLB = const(0xCF)  # Power Control B
_DTCTRLA = const(0xE8)  # Driver Timing Control A
_DTCTRLB = const(0xEA)  # Driver Timing Control B
_PWRONCTRL = const(0xED)  # Power on Sequence Control
_PRCTRL = const(0xF7)  # Pump Ratio Control
_PWCTRL1 = const(0xC0)  # Power Control 1
_PWCTRL2 = const(0xC1)  # Power Control 2
_VMCTRL1 = const(0xC5)  # VCOM Control 1
_VMCTRL2 = const(0xC7)  # VCOM Control 2
_FRMCTR1 = const(0xB1)  # Frame Rate Control 1
_DISCTRL = const(0xB6)  # Display Function Control
_EMS = const(0xB7)  # Entry Mode Set
_ENA3G = const(0xF2)  # Enable 3G
_PGAMCTRL = const(0xE0)  # Positive Gamma Control
_NGAMCTRL = const(0xE1)  # Negative Gamma Control

_CHUNK = const(1024)  # maximum number of pixels per spi write


class _ILI9341:

    def __init__(self, spi, cs, dc, rst, w, h, r):
        self.spi = spi
        self.cs = cs
        self.dc = dc
        self.rst = rst
        self._init_width = w
        self._init_height = h
        self.width = w
        self.height = h
        self.rotation = r
        self.cs.init(self.cs.OUT, value=1)
        self.dc.init(self.dc.OUT, value=0)
        self.rst.init(self.rst.OUT, value=0)
        self.reset()
        self.init()
        self._scroll = 0
        self._buf = bytearray(_CHUNK * 2)
        self._colormap = bytearray(
            b"\x00\x00\xff\xff"
        )  # default white foregraound, black background
        self._x = 0
        self._y = 0
        self._font = AdafruitGFX5x7Font
        self.scrolling = False

    def set_color(self, fg, bg):
        self._colormap[0] = bg >> 8
        self._colormap[1] = bg & 255
        self._colormap[2] = fg >> 8
        self._colormap[3] = fg & 255

    def set_pos(self, x, y):
        self._x = x
        self._y = y

    def reset_scroll(self):
        self.scrolling = False
        self._scroll = 0
        self.scroll(0)

    def set_font(self, font):
        self._font = font

    def init(self):
        for command, data in (
            (_RDDSDR, b"\x03\x80\x02"),
            (_PWCRTLB, b"\x00\xc1\x30"),
            (_PWRONCTRL, b"\x64\x03\x12\x81"),
            (_DTCTRLA, b"\x85\x00\x78"),
            (_PWCTRLA, b"\x39\x2c\x00\x34\x02"),
            (_PRCTRL, b"\x20"),
            (_DTCTRLB, b"\x00\x00"),
            (_PWCTRL1, b"\x23"),
            (_PWCTRL2, b"\x10"),
            (_VMCTRL1, b"\x3e\x28"),
            (_VMCTRL2, b"\x86"),
        ):
            self._write(command, data)

        if self.rotation == 0:  # 0 deg
            self._write(_MADCTL, b"\x48")  # BGR mode, top to bottom, left to right
            self.width = self._init_height
            self.height = self._init_width
        elif self.rotation == 1:  # 90 deg
            self._write(_MADCTL, b"\x28")  # BGR mode with rotation
            self.width = self._init_width
            self.height = self._init_height
        elif self.rotation == 2:  # 180 deg
            self._write(_MADCTL, b"\x88")  # BGR mode with rotation
            self.width = self._init_height
            self.height = self._init_width
        elif self.rotation == 3:  # 270 deg
            self._write(_MADCTL, b"\xe8")  # BGR mode with rotation
            self.width = self._init_width
            self.height = self._init_height
        elif self.rotation == 4:  # Mirrored + 0 deg
            self._write(_MADCTL, b"\xc8")  # BGR mode with mirroring
            self.width = self._init_height
            self.height = self._init_width
        elif self.rotation == 5:  # Mirrored + 90 deg
            self._write(_MADCTL, b"\x68")  # BGR mode with mirroring and rotation
            self.width = self._init_width
            self.height = self._init_height
        elif self.rotation == 6:  # Mirrored + 180 deg
            self._write(_MADCTL, b"\x08")  # BGR mode with mirroring and rotation
            self.width = self._init_height
            self.height = self._init_width
        elif self.rotation == 7:  # Mirrored + 270 deg
            self._write(_MADCTL, b"\xa8")  # BGR mode with mirroring and rotation
            self.width = self._init_width
            self.height = self._init_height
        else:
            self._write(_MADCTL, b"\x08")  # BGR mode default

        for command, data in (
            (_PIXSET, b"\x55"),
            (_FRMCTR1, b"\x00\x18"),
            (_DISCTRL, b"\x08\x82\x27"),
            (_ENA3G, b"\x00"),
            (_GAMSET, b"\x01"),
            (
                _PGAMCTRL,
                b"\x0f\x31\x2b\x0c\x0e\x08\x4e\xf1\x37\x07\x10\x03\x0e\x09\x00",
            ),
            (
                _NGAMCTRL,
                b"\x00\x0e\x14\x03\x11\x07\x31\xc1\x48\x08\x0f\x0c\x31\x36\x0f",
            ),
        ):
            self._write(command, data)

        self._write(
            _EMS, b"\xc6"
        )  # Entry mode set: normal display, 16-bit (RGB) to 18-bit (rgb) conversion

        self._write(_SLPOUT)
        sleep_ms(120)
        self._write(_DISPON)
        self._write(_INVON)  # Enable display inversion

    def reset(self):
        self.rst(0)
        sleep_ms(50)
        self.rst(1)
        sleep_ms(50)

    def _write(self, command, data=None):
        self.dc(0)
        self.cs(0)
        self.spi.write(bytearray([command]))
        self.cs(1)
        if data is not None:
            self._data(data)

    def _data(self, data):
        self.dc(1)
        self.cs(0)
        self.spi.write(data)
        self.cs(1)

    def _writeblock(self, x0, y0, x1, y1, data=None):
        self._write(_CASET, ustruct.pack(">HH", x0, x1))
        self._write(_PASET, ustruct.pack(">HH", y0, y1))
        self._write(_RAMWR, data)

    def _readblock(self, x0, y0, x1, y1, data=None):
        self._write(_CASET, ustruct.pack(">HH", x0, x1))
        self._write(_PASET, ustruct.pack(">HH", y0, y1))
        if data is None:
            return self._read(_RAMRD, (x1 - x0 + 1) * (y1 - y0 + 1) * 3)

    def _read(self, command, count):
        self.dc(0)
        self.cs(0)
        self.spi.write(bytearray([command]))
        data = self.spi.read(count)
        self.cs(1)
        return data

    def color565(self, r, g, b):
        return (r & 0xF8) << 8 | (g & 0xFC) << 3 | b >> 3

    def pixel(self, x, y, color=None):
        if color is None:
            r, b, g = self._readblock(x, y, x, y)
            return self.color565(r, g, b)
        if not 0 <= x < self.width or not 0 <= y < self.height:
            return
        self._writeblock(x, y, x, y, ustruct.pack(">H", color))

    def fill_rectangle(self, x, y, w, h, color=None):
        x = min(self.width - 1, max(0, x))
        y = min(self.height - 1, max(0, y))
        w = min(self.width - x, max(1, w))
        h = min(self.height - y, max(1, h))
        if color:
            color = ustruct.pack(">H", color)
        else:
            color = self._colormap[0:2]  # background
        for i in range(_CHUNK):
            self._buf[2 * i] = color[0]
            self._buf[2 * i + 1] = color[1]
        chunks, rest = divmod(w * h, _CHUNK)
        self._writeblock(x, y, x + w - 1, y + h - 1, None)
        if chunks:
            for count in range(chunks):
                self._data(self._buf)
        if rest != 0:
            mv = memoryview(self._buf)
            self._data(mv[: rest * 2])

    def erase(self):
        self.fill_rectangle(0, 0, self.width, self.height)

    def blit(self, bitbuff, x, y, w, h):
        x = min(self.width - 1, max(0, x))
        y = min(self.height - 1, max(0, y))
        w = min(self.width - x, max(1, w))
        h = min(self.height - y, max(1, h))
        chunks, rest = divmod(w * h, _CHUNK)
        self._writeblock(x, y, x + w - 1, y + h - 1, None)
        written = 0
        for iy in range(h):
            for ix in range(w):
                index = ix + iy * w - written
                if index >= _CHUNK:
                    self._data(self._buf)
                    written += _CHUNK
                    index -= _CHUNK
                c = bitbuff.pixel(ix, iy)
                self._buf[index * 2] = self._colormap[c * 2]
                self._buf[index * 2 + 1] = self._colormap[c * 2 + 1]
        rest = w * h - written
        if rest != 0:
            mv = memoryview(self._buf)
            self._data(mv[: rest * 2])

    def blit_buffer(self, buffer_data, x=0, y=0, w=None, h=None):
        if w is None:
            w = self.width
        if h is None:
            h = self.height

        # Clamp to display bounds
        x = min(self.width - 1, max(0, x))
        y = min(self.height - 1, max(0, y))
        w = min(self.width - x, max(1, w))
        h = min(self.height - y, max(1, h))

        # Set drawing window
        self._writeblock(x, y, x + w - 1, y + h - 1, None)

        buffer_view = memoryview(buffer_data)
        bytes_expected = w * h * 2

        self._data(buffer_view[:bytes_expected])

    def blit_line(self, line_data, x, y, w):
        if w <= 0 or y < 0 or y >= self.height:
            return

        x = max(0, x)
        w = min(w, self.width - x)

        if w > 0:
            self._writeblock(x, y, x + w - 1, y, None)
            bytes_to_send = w * 2  # RGB565 = 2 bytes per pixel
            if len(line_data) >= bytes_to_send:
                self._data(line_data[:bytes_to_send])

    def chars(self, str, x, y):
        import framebuf

        str_w = self._font.get_width(str)
        div, rem = divmod(self._font.height(), 8)
        nbytes = div + 1 if rem else div
        buf = bytearray(str_w * nbytes)
        pos = 0
        for ch in str:
            glyph, char_w = self._font.get_ch(ch)
            for row in range(nbytes):
                index = row * str_w + pos
                for i in range(char_w):
                    buf[index + i] = glyph[nbytes * i + row]
            pos += char_w
        fb = framebuf.FrameBuffer(buf, str_w, self._font.height(), framebuf.MONO_VLSB)
        self.blit(fb, x, y, str_w, self._font.height())
        return x + str_w

    def scroll(self, dy):
        self._scroll = (self._scroll + dy) % self.height
        self._write(_VSCRSADD, ustruct.pack(">H", self._scroll))

    def next_line(self, cury, char_h):
        global scrolling
        if not self.scrolling:
            res = cury + char_h
            self.scrolling = res >= self.height
        if self.scrolling:
            self.scroll(char_h)
            res = (self.height - char_h + self._scroll) % self.height
            self.fill_rectangle(0, res, self.width, self._font.height())
        return res

    def write(self, text):  # does character wrap, compatible with stream output
        curx = self._x
        cury = self._y
        char_h = self._font.height()
        width = 0
        written = 0
        for pos, ch in enumerate(text):
            if ch == "\n":
                if pos > 0:
                    self.chars(text[written:pos], curx, cury)
                curx = 0
                written = pos + 1
                width = 0
                cury = self.next_line(cury, char_h)
            else:
                char_w = self._font.get_width(ch)
                if curx + width + char_w >= self.width:
                    self.chars(text[written:pos], curx, cury)
                    curx = 0
                    written = pos
                    width = char_h
                    cury = self.next_line(cury, char_h)
                else:
                    width += char_w
        if written < len(text):
            curx = self.chars(text[written:], curx, cury)
        self._x = curx
        self._y = cury

    def print(self, text):  # does word wrap, leaves self._x unchanged
        cury = self._y
        curx = self._x
        char_h = self._font.height()
        char_w = self._font.max_width()
        lines = text.split("\n")
        for line in lines:
            words = line.split(" ")
            for word in words:
                if curx + self._font.get_width(word) >= self.width:
                    curx = self._x
                    cury = self.next_line(cury, char_h)
                    while self._font.get_width(word) > self.width:
                        self.chars(word[: self.width // char_w], curx, cury)
                        word = word[self.width // char_w :]
                        cury = self.next_line(cury, char_h)
                if len(word) > 0:
                    curx = self.chars(word + " ", curx, cury)
            curx = self._x
            cury = self.next_line(cury, char_h)
        self._y = cury


class AdafruitGFX5x7Font:
    # Original Adafruit_GFX 5x7 font data stored as a single bytes object.
    _font = (
        b"\x00\x00\x00\x00\x00"
        b"\x3e\x5b\x4f\x5b\x3e"
        b"\x3e\x6b\x4f\x6b\x3e"
        b"\x1c\x3e\x7c\x3e\x1c"
        b"\x18\x3c\x7e\x3c\x18"
        b"\x1c\x57\x7d\x57\x1c"
        b"\x1c\x5e\x7f\x5e\x1c"
        b"\x00\x18\x3c\x18\x00"
        b"\xff\xe7\xc3\xe7\xff"
        b"\x00\x18\x24\x18\x00"
        b"\xff\xe7\xdb\xe7\xff"
        b"\x30\x48\x3a\x06\x0e"
        b"\x26\x29\x79\x29\x26"
        b"\x40\x7f\x05\x05\x07"
        b"\x40\x7f\x05\x25\x3f"
        b"\x5a\x3c\xe7\x3c\x5a"
        b"\x7f\x3e\x1c\x1c\x08"
        b"\x08\x1c\x1c\x3e\x7f"
        b"\x14\x22\x7f\x22\x14"
        b"\x5f\x5f\x00\x5f\x5f"
        b"\x06\x09\x7f\x01\x7f"
        b"\x00\x66\x89\x95\x6a"
        b"\x60\x60\x60\x60\x60"
        b"\x94\xa2\xff\xa2\x94"
        b"\x08\x04\x7e\x04\x08"
        b"\x10\x20\x7e\x20\x10"
        b"\x08\x08\x2a\x1c\x08"
        b"\x08\x1c\x2a\x08\x08"
        b"\x1e\x10\x10\x10\x10"
        b"\x0c\x1e\x0c\x1e\x0c"
        b"\x30\x38\x3e\x38\x30"
        b"\x06\x0e\x3e\x0e\x06"
        b"\x00\x00\x00\x00\x00"
        b"\x00\x00\x5f\x00\x00"
        b"\x00\x07\x00\x07\x00"
        b"\x14\x7f\x14\x7f\x14"
        b"\x24\x2a\x7f\x2a\x12"
        b"\x23\x13\x08\x64\x62"
        b"\x36\x49\x56\x20\x50"
        b"\x00\x08\x07\x03\x00"
        b"\x00\x1c\x22\x41\x00"
        b"\x00\x41\x22\x1c\x00"
        b"\x2a\x1c\x7f\x1c\x2a"
        b"\x08\x08\x3e\x08\x08"
        b"\x00\x80\x70\x30\x00"
        b"\x08\x08\x08\x08\x08"
        b"\x00\x00\x60\x60\x00"
        b"\x20\x10\x08\x04\x02"
        b"\x3e\x51\x49\x45\x3e"
        b"\x00\x42\x7f\x40\x00"
        b"\x72\x49\x49\x49\x46"
        b"\x21\x41\x49\x4d\x33"
        b"\x18\x14\x12\x7f\x10"
        b"\x27\x45\x45\x45\x39"
        b"\x3c\x4a\x49\x49\x31"
        b"\x41\x21\x11\x09\x07"
        b"\x36\x49\x49\x49\x36"
        b"\x46\x49\x49\x29\x1e"
        b"\x00\x00\x14\x00\x00"
        b"\x00\x40\x34\x00\x00"
        b"\x00\x08\x14\x22\x41"
        b"\x14\x14\x14\x14\x14"
        b"\x00\x41\x22\x14\x08"
        b"\x02\x01\x59\x09\x06"
        b"\x3e\x41\x5d\x59\x4e"
        b"\x7c\x12\x11\x12\x7c"
        b"\x7f\x49\x49\x49\x36"
        b"\x3e\x41\x41\x41\x22"
        b"\x7f\x41\x41\x41\x3e"
        b"\x7f\x49\x49\x49\x41"
        b"\x7f\x09\x09\x09\x01"
        b"\x3e\x41\x41\x51\x73"
        b"\x7f\x08\x08\x08\x7f"
        b"\x00\x41\x7f\x41\x00"
        b"\x20\x40\x41\x3f\x01"
        b"\x7f\x08\x14\x22\x41"
        b"\x7f\x40\x40\x40\x40"
        b"\x7f\x02\x1c\x02\x7f"
        b"\x7f\x04\x08\x10\x7f"
        b"\x3e\x41\x41\x41\x3e"
        b"\x7f\x09\x09\x09\x06"
        b"\x3e\x41\x51\x21\x5e"
        b"\x7f\x09\x19\x29\x46"
        b"\x26\x49\x49\x49\x32"
        b"\x03\x01\x7f\x01\x03"
        b"\x3f\x40\x40\x40\x3f"
        b"\x1f\x20\x40\x20\x1f"
        b"\x3f\x40\x38\x40\x3f"
        b"\x63\x14\x08\x14\x63"
        b"\x03\x04\x78\x04\x03"
        b"\x61\x59\x49\x4d\x43"
        b"\x00\x7f\x41\x41\x41"
        b"\x02\x04\x08\x10\x20"
        b"\x00\x41\x41\x41\x7f"
        b"\x04\x02\x01\x02\x04"
        b"\x40\x40\x40\x40\x40"
        b"\x00\x03\x07\x08\x00"
        b"\x20\x54\x54\x78\x40"
        b"\x7f\x28\x44\x44\x38"
        b"\x38\x44\x44\x44\x28"
        b"\x38\x44\x44\x28\x7f"
        b"\x38\x54\x54\x54\x18"
        b"\x00\x08\x7e\x09\x02"
        b"\x18\xa4\xa4\x9c\x78"
        b"\x7f\x08\x04\x04\x78"
        b"\x00\x44\x7d\x40\x00"
        b"\x20\x40\x40\x3d\x00"
        b"\x7f\x10\x28\x44\x00"
        b"\x00\x41\x7f\x40\x00"
        b"\x7c\x04\x78\x04\x78"
        b"\x7c\x08\x04\x04\x78"
        b"\x38\x44\x44\x44\x38"
        b"\xfc\x18\x24\x24\x18"
        b"\x18\x24\x24\x18\xfc"
        b"\x7c\x08\x04\x04\x08"
        b"\x48\x54\x54\x54\x24"
        b"\x04\x04\x3f\x44\x24"
        b"\x3c\x40\x40\x20\x7c"
        b"\x1c\x20\x40\x20\x1c"
        b"\x3c\x40\x30\x40\x3c"
        b"\x44\x28\x10\x28\x44"
        b"\x4c\x90\x90\x90\x7c"
        b"\x44\x64\x54\x4c\x44"
        b"\x00\x08\x36\x41\x00"
        b"\x00\x00\x77\x00\x00"
        b"\x00\x41\x36\x08\x00"
        b"\x02\x01\x02\x04\x02"
        b"\x3c\x26\x23\x26\x3c"
        b"\x1e\xa1\xa1\x61\x12"
        b"\x3a\x40\x40\x20\x7a"
        b"\x38\x54\x54\x55\x59"
        b"\x21\x55\x55\x79\x41"
        b"\x21\x54\x54\x78\x41"
        b"\x21\x55\x54\x78\x40"
        b"\x20\x54\x55\x79\x40"
        b"\x0c\x1e\x52\x72\x12"
        b"\x39\x55\x55\x55\x59"
        b"\x39\x54\x54\x54\x59"
        b"\x39\x55\x54\x54\x58"
        b"\x00\x00\x45\x7c\x41"
        b"\x00\x02\x45\x7d\x42"
        b"\x00\x01\x45\x7c\x40"
        b"\xf0\x29\x24\x29\xf0"
        b"\xf0\x28\x25\x28\xf0"
        b"\x7c\x54\x55\x45\x00"
        b"\x20\x54\x54\x7c\x54"
        b"\x7c\x0a\x09\x7f\x49"
        b"\x32\x49\x49\x49\x32"
        b"\x32\x48\x48\x48\x32"
        b"\x32\x4a\x48\x48\x30"
        b"\x3a\x41\x41\x21\x7a"
        b"\x3a\x42\x40\x20\x78"
        b"\x00\x9d\xa0\xa0\x7d"
        b"\x39\x44\x44\x44\x39"
        b"\x3d\x40\x40\x40\x3d"
        b"\x3c\x24\xff\x24\x24"
        b"\x48\x7e\x49\x43\x66"
        b"\x2b\x2f\xfc\x2f\x2b"
        b"\xff\x09\x29\xf6\x20"
        b"\xc0\x88\x7e\x09\x03"
        b"\x20\x54\x54\x79\x41"
        b"\x00\x00\x44\x7d\x41"
        b"\x30\x48\x48\x4a\x32"
        b"\x38\x40\x40\x22\x7a"
        b"\x00\x7a\x0a\x0a\x72"
        b"\x7d\x0d\x19\x31\x7d"
        b"\x26\x29\x29\x2f\x28"
        b"\x26\x29\x29\x29\x26"
        b"\x30\x48\x4d\x40\x20"
        b"\x38\x08\x08\x08\x08"
        b"\x08\x08\x08\x08\x38"
        b"\x2f\x10\xc8\xac\xba"
        b"\x2f\x10\x28\x34\xfa"
        b"\x00\x00\x7b\x00\x00"
        b"\x08\x14\x2a\x14\x22"
        b"\x22\x14\x2a\x14\x08"
        b"\xaa\x00\x55\x00\xaa"
        b"\xaa\x55\xaa\x55\xaa"
        b"\x00\x00\x00\xff\x00"
        b"\x10\x10\x10\xff\x00"
        b"\x14\x14\x14\xff\x00"
        b"\x10\x10\xff\x00\xff"
        b"\x10\x10\xf0\x10\xf0"
        b"\x14\x14\x14\xfc\x00"
        b"\x14\x14\xf7\x00\xff"
        b"\x00\x00\xff\x00\xff"
        b"\x14\x14\xf4\x04\xfc"
        b"\x14\x14\x17\x10\x1f"
        b"\x10\x10\x1f\x10\x1f"
        b"\x14\x14\x14\x1f\x00"
        b"\x10\x10\x10\xf0\x00"
        b"\x00\x00\x00\x1f\x10"
        b"\x10\x10\x10\x1f\x10"
        b"\x10\x10\x10\xf0\x10"
        b"\x00\x00\x00\xff\x10"
        b"\x10\x10\x10\x10\x10"
        b"\x10\x10\x10\xff\x10"
        b"\x00\x00\x00\xff\x14"
        b"\x00\x00\xff\x00\xff"
        b"\x00\x00\x1f\x10\x17"
        b"\x00\x00\xfc\x04\xf4"
        b"\x14\x14\x17\x10\x17"
        b"\x14\x14\xf4\x04\xf4"
        b"\x00\x00\xff\x00\xf7"
        b"\x14\x14\x14\x14\x14"
        b"\x14\x14\xf7\x00\xf7"
        b"\x14\x14\x14\x17\x14"
        b"\x10\x10\x1f\x10\x1f"
        b"\x14\x14\x14\xf4\x14"
        b"\x10\x10\xf0\x10\xf0"
        b"\x00\x00\x1f\x10\x1f"
        b"\x00\x00\x00\x1f\x14"
        b"\x00\x00\x00\xfc\x14"
        b"\x00\x00\xf0\x10\xf0"
        b"\x10\x10\xff\x10\xff"
        b"\x14\x14\x14\xff\x14"
        b"\x10\x10\x10\x1f\x00"
        b"\x00\x00\x00\xf0\x10"
        b"\xff\xff\xff\xff\xff"
        b"\xf0\xf0\xf0\xf0\xf0"
        b"\xff\xff\xff\x00\x00"
        b"\x00\x00\x00\xff\xff"
        b"\x0f\x0f\x0f\x0f\x0f"
        b"\x38\x44\x44\x38\x44"
        b"\x7c\x2a\x2a\x3e\x14"
        b"\x7e\x02\x02\x06\x06"
        b"\x02\x7e\x02\x7e\x02"
        b"\x63\x55\x49\x41\x63"
        b"\x38\x44\x44\x3c\x04"
        b"\x40\x7e\x20\x1e\x20"
        b"\x06\x02\x7e\x02\x02"
        b"\x99\xa5\xe7\xa5\x99"
        b"\x1c\x2a\x49\x2a\x1c"
        b"\x4c\x72\x01\x72\x4c"
        b"\x30\x4a\x4d\x4d\x30"
        b"\x30\x48\x78\x48\x30"
        b"\xbc\x62\x5a\x46\x3d"
        b"\x3e\x49\x49\x49\x00"
        b"\x7e\x01\x01\x01\x7e"
        b"\x2a\x2a\x2a\x2a\x2a"
        b"\x44\x44\x5f\x44\x44"
        b"\x40\x51\x4a\x44\x40"
        b"\x40\x44\x4a\x51\x40"
        b"\x00\x00\xff\x01\x03"
        b"\xe0\x80\xff\x00\x00"
        b"\x08\x08\x6b\x6b\x08"
        b"\x36\x12\x36\x24\x36"
        b"\x06\x0f\x09\x0f\x06"
        b"\x00\x00\x18\x18\x00"
        b"\x00\x00\x10\x10\x00"
        b"\x30\x40\xff\x01\x01"
        b"\x00\x1f\x01\x01\x1e"
        b"\x00\x19\x1d\x17\x12"
        b"\x00\x3c\x3c\x3c\x3c"
        b"\x00\x00\x00\x00\x00"
    )

    # Create a memoryview for fast slicing.
    _mvfont = memoryview(_font)

    @classmethod
    def height(cls):
        """Return the height of the font."""
        return 8

    @classmethod
    def max_width(cls):
        """Return the maximum width of a character in the font."""
        return 6

    @classmethod
    def hmap(cls):
        """Return the hmap property (unused in this font)."""
        return False

    @classmethod
    def reverse(cls):
        """Return whether the font is reversed."""
        return False

    @classmethod
    def monospaced(cls):
        """Return whether the font is monospaced."""
        return True

    @classmethod
    def min_ch(cls):
        """Return the minimum character code in the font."""
        return 0

    @classmethod
    def max_ch(cls):
        """Return the maximum character code in the font."""
        return 255

    @classmethod
    def get_width(cls, s):
        """
        Get the width in pixels of the string `s`.

        Since each character is 6 pixels wide, this is simply:
            len(s) * 6
        """
        return len(s) * 6

    @classmethod
    def get_ch(cls, ch):
        """
        Retrieve the bitmap for the character `ch`.

        The font stores 5 bytes per character. The returned bytearray is 6 bytes
        long, with the first byte set to 0 (for spacing) and the following 5 bytes
        copied from the font data.

        Returns:
            A tuple of (bytearray, width), where width is always 6.
        """
        ordch = ord(ch)
        offset = ordch * 5
        buf = bytearray(6)
        buf[0] = 0
        buf[1:] = cls._mvfont[offset : offset + 5]
        return buf, 6
